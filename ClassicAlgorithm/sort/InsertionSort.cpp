#include "InsertionSort.h"



InsertionSort::InsertionSort()
{
}


InsertionSort::~InsertionSort()
{
}


/*
插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌
对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。
插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，
需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
具体算法描述如下：
    1.从第一个元素开始，该元素可以认为已经被排序
    2.取出下一个元素，在已经排序的元素序列中从后向前扫描
    3.如果该元素（已排序）大于新元素，将该元素移到下一位置
    4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
    5.将新元素插入到该位置后
    6.重复步骤2~5

插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。
插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，
用于少量元素的排序（通常为8个或以下）。
*/

// 分类 ------------- 内部比较排序
// 数据结构 ---------- 数组
// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)
// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 稳定

void InsertionSort::sort(int arr[], uint size)
{
	if (!arr || size < 2)
		return;

	// 类似抓扑克牌排序
	// 从第2个元素开始, 左边第1个元认为已经排序完成
	for (uint i = 1; i < size; ++i)
	{
		// 当前值
		// 右手抓到一张扑克牌
		int curVal = arr[i];

		// 拿在左手上的牌总是排序好的, 将抓到的牌与手牌从右向左进行比较
		// 从左边i - 1个已经排序完成的元素中倒叙遍历, 查找第1个不大于当前第i个元素值的位置
		int j = i - 1;
		while (j >= 0 && arr[j] > curVal)
		{
			// 如果该手牌比抓到的牌大，就将其右移
			arr[j + 1] = arr[j];
			--j;
		}

		// 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序未变，所以插入排序是稳定的)
        // j + 1:该手牌右边, 上面最后执行的是--j
		arr[j + 1] = curVal;
	}
}


int main_is(int argc, char* argv[])
{
	int arr[12] = { 4, 3, 2, 1, 0, 9, 8, 7, 4, 2, -1, 2 };
	//int arr[9] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };
	int size = sizeof(arr) / sizeof(arr[0]);
	InsertionSort st;

	printf("排序前:\n");
	printArr(arr, size);
	st.sort(arr, size);
	printf("排序后:\n");
	printArr(arr, size);

	return 0;
}